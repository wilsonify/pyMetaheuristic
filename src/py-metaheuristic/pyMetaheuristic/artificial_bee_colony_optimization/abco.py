"""
Artificial bee colony (ABC) is a population-based stochastic algorithm
which has shown good search abilities on many optimization problems.

A solution pool is constructed by storing some best solutions of the current swarm.
New candidate solutions are generated by searching the neighborhood of solutions
randomly chosen from the solution pool.

"""

############################################################################

# Created by: Prof. Valdecy Pereira, D.Sc.
# UFF - Universidade Federal Fluminense (Brazil)
# email:  valdecy.pereira@gmail.com
# Course: Metaheuristics
# Lesson: Artificial Bee Colony Optimization

# Citation:
# PEREIRA, V. (2018). Project: Metaheuristic-Artificial_Bee_Colony_Optimization,
# File: Python-MH-Artificial Bee Colony Optimization.py,
# GitHub repository: <https://github.com/Valdecy/Metaheuristic-Artificial_Bee_Colony_Optimization>

############################################################################

import os
import random

import numpy as np
from pyMetaheuristic import rando


class ArtificialBeeColony():
    """
    Initial food sources are produced for all employed bees
    REPEAT
        * Each employed bee goes to a food source in her memory and determines a closest source,
        then evaluates its nectar amount and dances in the hive
        * Each onlooker watches the dance of employed bees and chooses one of their sources depending on the dances,
        and then goes to that source.
        After choosing a neighbour around that, she evaluates its nectar amount.
        * Abandoned food sources are determined and are replaced with the new food sources discovered by scouts.
        * The best food source found so far is registered.
    UNTIL (requirements are met)

    """

    def __init__(self,
                 target_function,
                 food_sources=3,
                 iterations=50,
                 min_values=(-5, -5),
                 max_values=(5, 5),
                 employed_bees=3,
                 outlookers_bees=3,
                 limit=3,
                 ):
        """

        :param target_function:
        :param food_sources:
        :param iterations:
        :param min_values:
        :param max_values:
        :param employed_bees:
        :param outlookers_bees:
        :param limit:
        """
        self.target_function = target_function
        self.food_sources = food_sources
        self.iterations = iterations
        self.min_values = min_values
        self.max_values = max_values
        self.employed_bees = employed_bees
        self.outlookers_bees = outlookers_bees
        self.limit = limit
        self.sources = np.zeros((food_sources, len(min_values) + 1))
        self.sources = self.initial_sources()

        self.searching_in_sources = np.copy(self.sources)
        self.fitness = np.zeros((self.searching_in_sources.shape[0], 2))
        self.new_solution = np.zeros((1, len(min_values)))
        self.trial = np.zeros((self.sources.shape[0], 1))
        self.improving_sources = np.copy(self.searching_in_sources)
        self.new_solution = np.zeros((1, len(self.min_values)))
        self.trial_update = np.copy(self.trial)

    def initial_sources(self):
        """ Initialize Variables """
        for i in range(self.food_sources):
            for j in range(len(self.min_values)):
                self.sources[i, j] = random.uniform(self.min_values[j], self.max_values[j])
            self.sources[i, -1] = self.target_function(self.sources[i, 0: self.sources.shape[1] - 1])
        return self.sources

    @staticmethod
    def fitness_calc(function_value):
        """ Fitness Value"""
        if function_value >= 0:
            fitness_value = 1.0 / (1.0 + function_value)
        else:
            fitness_value = 1.0 + abs(function_value)
        return fitness_value

    def fitness_function(self, searching_in_sources):
        """Fitness"""

        for i in range(self.fitness.shape[0]):
            # fitness[i,0] = 1/(1+ searching_in_sources[i,-1] + abs(searching_in_sources[:,-1].min()))
            self.fitness[i, 0] = self.fitness_calc(searching_in_sources[i, -1])
        fit_sum = self.fitness[:, 0].sum()
        self.fitness[0, 1] = self.fitness[0, 0]
        for i in range(1, self.fitness.shape[0]):
            self.fitness[i, 1] = self.fitness[i, 0] + self.fitness[i - 1, 1]
        for i in range(self.fitness.shape[0]):
            self.fitness[i, 1] = self.fitness[i, 1] / fit_sum
        return self.fitness

    def roulette_wheel(self):
        """Selection"""
        ix = 0
        _random = rando()
        for i in range(self.fitness.shape[0]):
            if _random <= self.fitness[i, 1]:
                ix = i
                break
        return ix

    def employed_bee(self):
        """ Bees with jobs """
        for i in range(self.searching_in_sources.shape[0]):
            phi = random.uniform(-1, 1)
            j = np.random.randint(len(self.min_values), size=1)[0]
            k = np.random.randint(self.searching_in_sources.shape[0], size=1)[0]
            while i == k:
                k = np.random.randint(self.searching_in_sources.shape[0], size=1)[0]
            xij = self.searching_in_sources[i, j]
            xkj = self.searching_in_sources[k, j]
            vij = xij + phi * (xij - xkj)
            for variable in range(len(self.min_values)):
                self.new_solution[0, variable] = self.searching_in_sources[i, variable]
            self.new_solution[0, j] = np.clip(vij, self.min_values[j], self.max_values[j])
            new_function_value = self.target_function(self.new_solution[0, 0: self.new_solution.shape[1]])
            if self.fitness_calc(new_function_value) > self.fitness_calc(self.searching_in_sources[i, -1]):
                self.searching_in_sources[i, j] = self.new_solution[0, j]
                self.searching_in_sources[i, -1] = new_function_value
            else:
                self.trial[i, 0] = self.trial[i, 0] + 1
            for variable in range(len(self.min_values)):
                self.new_solution[0, variable] = 0.0
        return self.searching_in_sources, self.trial

    def outlooker_bee(self):
        """Outlooker"""
        for _ in range(self.improving_sources.shape[0]):
            i = self.roulette_wheel()
            phi = random.uniform(-1, 1)
            j = np.random.randint(len(self.min_values), size=1)[0]
            k = np.random.randint(self.improving_sources.shape[0], size=1)[0]
            while i == k:
                k = np.random.randint(self.improving_sources.shape[0], size=1)[0]
            xij = self.improving_sources[i, j]
            xkj = self.improving_sources[k, j]
            vij = xij + phi * (xij - xkj)
            for variable in range(len(self.min_values)):
                self.new_solution[0, variable] = self.improving_sources[i, variable]
            self.new_solution[0, j] = np.clip(vij, self.min_values[j], self.max_values[j])
            new_function_value = self.target_function(self.new_solution[0, 0: self.new_solution.shape[1]])
            if self.fitness_calc(new_function_value) > self.fitness_calc(self.improving_sources[i, -1]):
                self.improving_sources[i, j] = self.new_solution[0, j]
                self.improving_sources[i, -1] = new_function_value
                self.trial_update[i, 0] = 0
            else:
                self.trial_update[i, 0] = self.trial_update[i, 0] + 1
            for variable in range(len(self.min_values)):
                self.new_solution[0, variable] = 0.0
        return self.improving_sources, self.trial_update

    def scouter_bee(self):
        """Scouter"""
        for i in range(self.improving_sources.shape[0]):
            if self.trial_update[i, 0] > self.limit:
                for j in range(self.improving_sources.shape[1] - 1):
                    self.improving_sources[i, j] = np.random.normal(0, 1, 1)[0]
                function_value = self.target_function(
                    self.improving_sources[i, 0: self.improving_sources.shape[1] - 1]
                )
                self.improving_sources[i, -1] = function_value
        return self.improving_sources

    # ABC Function
    def minimize(self):
        """ minimize """
        count = 0
        best_value = float("inf")

        self.fitness = self.fitness_function(self.sources)
        while count <= self.iterations:
            if count > 0:
                print("Iteration = ", count, " f(x) = ", best_value)
            e_bee = self.employed_bee()
            for _ in range(self.employed_bees - 1):
                e_bee = self.employed_bee()
            self.fitness = self.fitness_function(e_bee[0])
            o_bee = self.outlooker_bee()
            for _ in range(self.outlookers_bees - 1):
                o_bee = self.outlooker_bee()
            value = np.copy(o_bee[0][o_bee[0][:, -1].argsort()][0, :])
            if best_value > value[-1]:
                best_solution = np.copy(value)
                best_value = np.copy(value[-1])
            sources = self.scouter_bee()
            self.fitness = self.fitness_function(sources)
            count = count + 1
        print(best_solution)
        return best_solution
